- Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request
    along the chain until an object handles it.
- Launch-and-leave requests with a single processing pipeline that contains many possible handlers.
- An object-oriented linked list with recursive traversal.

The pattern chains the receiving objects together, and then passes any request messages from object to object until it reaches an object capable of handling the message.
The number and type of handler objects isn't known a priori, they can be configured dynamically. The chaining mechanism uses recursive composition to allow an unlimited number of
handlers to be linked

Check list
The base class maintains a "next" pointer.
Each derived class implements its contribution for handling the request.
If the request needs to be "passed on", then the derived class "calls back" to the base class, which delegates to the "next" pointer.
The client (or some third party) creates and links the chain (which may include a link from the last node to the root node).
The client "launches and leaves" each request with the root of the chain.
Recursive delegation produces the illusion of magic.

Motivation

In writing an application of any kind, it often happens that the event generated by one object needs to be handled by another one. And, to make our work even harder, we also happen to be denied access to the object which needs to handle the event. In this case there are two possibilities: there is the beginner/lazy approach of making everything public, creating reference to every object and continuing from there and then there is the expert approach of using the Chain of Responsibility.

The Chain of Responsibility design pattern allows an object to send a command without knowing what object will receive and handle it. The request is sent from one object to another making them parts of a chain and each object in this chain can handle the command, pass it on or do both. The most usual example of a machine using the Chain of Responsibility is the vending machine coin slot: rather than having a slot for each type of coin, the machine has only one slot for all of them. The dropped coin is routed to the appropriate storage place that is determined by the receiver of the command.

Intent:
It avoids attaching the sender of a request to its receiver, giving this way other objects the possibility of handling the request too.
The objects become parts of a chain and the request is sent from one object to another across the chain until one of the objects will handle it.



http://www.oodesign.com/chain-of-responsibility-pattern.html
https://sourcemaking.com/design_patterns/chain_of_responsibility/java/2
